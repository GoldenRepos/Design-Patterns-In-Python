{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Design Patterns In Python The tutorials in this documentation supplement my Design Patterns in Python Courses on Skillshare and Udemy . To register for this course visit * Get 2 Months Free Premium Membership to 1000s of Courses * Full Lifetime Access * Subscription Model * Cancel Any Time Click Here to Register at Skillshare * New Student Discount * Full Lifetime Access * Certificate of Completion * 30 Day Money-Back Guarantee Click Here to Register at Udemy This course is about common GOF (Gang Of Four) Design Patterns implemented in Python. A Design Pattern is a description or template that can be repeatedly applied to a commonly recurring problem in software design. You will find a familiarity with Design Patterns very useful when planning, discussing, developing, managing and documenting your applications from now on and into the future. You will learn these Design Patterns Creational Factory Abstract Factory Builder Prototype Singleton Structural Decorator Adapter Facade Bridge Composite Flyweight Proxy Behavioural Command Chain of Responsibility Observer Pattern Interpreter Iterator Mediator Memento State Strategy Template Visitor Introduction Video","title":"Home"},{"location":"#design-patterns-in-python","text":"The tutorials in this documentation supplement my Design Patterns in Python Courses on Skillshare and Udemy . To register for this course visit * Get 2 Months Free Premium Membership to 1000s of Courses * Full Lifetime Access * Subscription Model * Cancel Any Time Click Here to Register at Skillshare * New Student Discount * Full Lifetime Access * Certificate of Completion * 30 Day Money-Back Guarantee Click Here to Register at Udemy This course is about common GOF (Gang Of Four) Design Patterns implemented in Python. A Design Pattern is a description or template that can be repeatedly applied to a commonly recurring problem in software design. You will find a familiarity with Design Patterns very useful when planning, discussing, developing, managing and documenting your applications from now on and into the future. You will learn these Design Patterns Creational Factory Abstract Factory Builder Prototype Singleton Structural Decorator Adapter Facade Bridge Composite Flyweight Proxy Behavioural Command Chain of Responsibility Observer Pattern Interpreter Iterator Mediator Memento State Strategy Template Visitor","title":"Design Patterns In Python"},{"location":"#introduction-video","text":"","title":"Introduction Video"},{"location":"abstract_factory/","text":"Abstract Factory Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Abstract Factory Design Pattern Description The Abstract Factory Pattern adds an abstract layer over multiple factory method implementations. The Abstract Factory contains or composites one or more than one factory method Abstract Factory in the context of a Furniture factory Source Code chair_factory.py from abc import ABCMeta , abstractstaticmethod class IChair ( metaclass = ABCMeta ): # pylint: disable=too-few-public-methods \"\"\"The Chair Interface\"\"\" @abstractstaticmethod def dimensions (): \"\"\"A static inteface method\"\"\" class BigChair ( IChair ): # pylint: disable=too-few-public-methods \"\"\"The Big Chair Concrete Class which implements the IChair interface\"\"\" def __init__ ( self ): self . _height = 80 self . _width = 80 self . _depth = 80 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class MediumChair ( IChair ): # pylint: disable=too-few-public-methods \"\"\"The Medium Chair Concrete Class which implements the IChair interface\"\"\" def __init__ ( self ): self . _height = 60 self . _width = 60 self . _depth = 60 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class SmallChair ( IChair ): # pylint: disable=too-few-public-methods \"\"\"The Small Chair Concrete Class which implements the IChair interface\"\"\" def __init__ ( self ): self . _height = 40 self . _width = 40 self . _depth = 40 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class ChairFactory : # pylint: disable=too-few-public-methods \"\"\"Tha Factory Class\"\"\" @staticmethod def get_chair ( chair ): \"\"\"A static method to get a table\"\"\" try : if chair == \"BigChair\" : return BigChair () if chair == \"MediumChair\" : return MediumChair () if chair == \"SmallChair\" : return SmallChair () raise AssertionError ( \"Chair Not Found\" ) except AssertionError as _e : print ( _e ) return None if __name__ == \"__main__\" : CHAIR_FACTORY = ChairFactory () . get_chair ( \"SmallChair\" ) print ( CHAIR_FACTORY . dimensions ()) table_factory.py from abc import ABCMeta , abstractstaticmethod class ITable ( metaclass = ABCMeta ): # pylint: disable=too-few-public-methods \"\"\"The Table Interface\"\"\" @abstractstaticmethod def dimensions (): \"\"\"Get the table dimensions\"\"\" class BigTable ( ITable ): # pylint: disable=too-few-public-methods \"\"\"The Big Table Concrete Class which implements the ITable interface\"\"\" def __init__ ( self ): self . _height = 60 self . _width = 120 self . _depth = 80 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class MediumTable ( ITable ): # pylint: disable=too-few-public-methods \"\"\"The Medium Table Concrete Class which implements the ITable interface\"\"\" def __init__ ( self ): self . _height = 60 self . _width = 110 self . _depth = 70 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class SmallTable ( ITable ): # pylint: disable=too-few-public-methods \"\"\"The Small Table Concrete Class which implements the ITable interface\"\"\" def __init__ ( self ): self . _height = 60 self . _width = 100 self . _depth = 60 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class TableFactory : # pylint: disable=too-few-public-methods \"\"\"Tha Factory Class\"\"\" @staticmethod def get_table ( table ): \"\"\"A static method to get a table\"\"\" try : if table == \"BigTable\" : return BigTable () if table == \"MediumTable\" : return MediumTable () if table == \"SmallTable\" : return SmallTable () raise AssertionError ( \"Table Not Found\" ) except AssertionError as _e : print ( _e ) return None if __name__ == \"__main__\" : TABLE = TableFactory () . get_table ( \"SmalTable\" ) print ( TABLE ) furniture_abstract_factory.py from abc import ABCMeta , abstractstaticmethod from chair_factory import ChairFactory from table_factory import TableFactory class IFurnitureFactory ( metaclass = ABCMeta ): # pylint: disable=too-few-public-methods \"\"\"Furniture Factory Interface\"\"\" @abstractstaticmethod def get_furniture ( furniture ): \"\"\"The static funiture factory inteface method\"\"\" class FurnitureFactory ( IFurnitureFactory ): # pylint: disable=too-few-public-methods \"\"\"The Furniture Factory Concrete Class\"\"\" @staticmethod def get_furniture ( furniture ): \"\"\"Static get_furniture method\"\"\" try : if furniture in [ \"SmallChair\" , \"MediumChair\" , \"BigChair\" ]: return ChairFactory () . get_chair ( furniture ) if furniture in [ \"SmallTable\" , \"MediumTable\" , \"BigTable\" ]: return TableFactory () . get_table ( furniture ) raise AssertionError ( \"No Furniture Factory Found\" ) except AssertionError as _e : print ( _e ) return None FURNITURE = FurnitureFactory . get_furniture ( \"SmallChair\" ) print ( f \"{FURNITURE.__class__} : {FURNITURE.dimensions()}\" ) FURNITURE = FurnitureFactory . get_furniture ( \"MediumTable\" ) print ( f \"{FURNITURE.__class__} : {FURNITURE.dimensions()}\" )","title":"Abstract Factory"},{"location":"abstract_factory/#abstract-factory-design-pattern","text":"","title":"Abstract Factory Design Pattern"},{"location":"abstract_factory/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Abstract Factory Design Pattern","title":"Video Lecture"},{"location":"abstract_factory/#description","text":"The Abstract Factory Pattern adds an abstract layer over multiple factory method implementations. The Abstract Factory contains or composites one or more than one factory method Abstract Factory in the context of a Furniture factory","title":"Description"},{"location":"abstract_factory/#source-code","text":"","title":"Source Code"},{"location":"abstract_factory/#chair_factorypy","text":"from abc import ABCMeta , abstractstaticmethod class IChair ( metaclass = ABCMeta ): # pylint: disable=too-few-public-methods \"\"\"The Chair Interface\"\"\" @abstractstaticmethod def dimensions (): \"\"\"A static inteface method\"\"\" class BigChair ( IChair ): # pylint: disable=too-few-public-methods \"\"\"The Big Chair Concrete Class which implements the IChair interface\"\"\" def __init__ ( self ): self . _height = 80 self . _width = 80 self . _depth = 80 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class MediumChair ( IChair ): # pylint: disable=too-few-public-methods \"\"\"The Medium Chair Concrete Class which implements the IChair interface\"\"\" def __init__ ( self ): self . _height = 60 self . _width = 60 self . _depth = 60 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class SmallChair ( IChair ): # pylint: disable=too-few-public-methods \"\"\"The Small Chair Concrete Class which implements the IChair interface\"\"\" def __init__ ( self ): self . _height = 40 self . _width = 40 self . _depth = 40 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class ChairFactory : # pylint: disable=too-few-public-methods \"\"\"Tha Factory Class\"\"\" @staticmethod def get_chair ( chair ): \"\"\"A static method to get a table\"\"\" try : if chair == \"BigChair\" : return BigChair () if chair == \"MediumChair\" : return MediumChair () if chair == \"SmallChair\" : return SmallChair () raise AssertionError ( \"Chair Not Found\" ) except AssertionError as _e : print ( _e ) return None if __name__ == \"__main__\" : CHAIR_FACTORY = ChairFactory () . get_chair ( \"SmallChair\" ) print ( CHAIR_FACTORY . dimensions ())","title":"chair_factory.py"},{"location":"abstract_factory/#table_factorypy","text":"from abc import ABCMeta , abstractstaticmethod class ITable ( metaclass = ABCMeta ): # pylint: disable=too-few-public-methods \"\"\"The Table Interface\"\"\" @abstractstaticmethod def dimensions (): \"\"\"Get the table dimensions\"\"\" class BigTable ( ITable ): # pylint: disable=too-few-public-methods \"\"\"The Big Table Concrete Class which implements the ITable interface\"\"\" def __init__ ( self ): self . _height = 60 self . _width = 120 self . _depth = 80 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class MediumTable ( ITable ): # pylint: disable=too-few-public-methods \"\"\"The Medium Table Concrete Class which implements the ITable interface\"\"\" def __init__ ( self ): self . _height = 60 self . _width = 110 self . _depth = 70 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class SmallTable ( ITable ): # pylint: disable=too-few-public-methods \"\"\"The Small Table Concrete Class which implements the ITable interface\"\"\" def __init__ ( self ): self . _height = 60 self . _width = 100 self . _depth = 60 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class TableFactory : # pylint: disable=too-few-public-methods \"\"\"Tha Factory Class\"\"\" @staticmethod def get_table ( table ): \"\"\"A static method to get a table\"\"\" try : if table == \"BigTable\" : return BigTable () if table == \"MediumTable\" : return MediumTable () if table == \"SmallTable\" : return SmallTable () raise AssertionError ( \"Table Not Found\" ) except AssertionError as _e : print ( _e ) return None if __name__ == \"__main__\" : TABLE = TableFactory () . get_table ( \"SmalTable\" ) print ( TABLE )","title":"table_factory.py"},{"location":"abstract_factory/#furniture_abstract_factorypy","text":"from abc import ABCMeta , abstractstaticmethod from chair_factory import ChairFactory from table_factory import TableFactory class IFurnitureFactory ( metaclass = ABCMeta ): # pylint: disable=too-few-public-methods \"\"\"Furniture Factory Interface\"\"\" @abstractstaticmethod def get_furniture ( furniture ): \"\"\"The static funiture factory inteface method\"\"\" class FurnitureFactory ( IFurnitureFactory ): # pylint: disable=too-few-public-methods \"\"\"The Furniture Factory Concrete Class\"\"\" @staticmethod def get_furniture ( furniture ): \"\"\"Static get_furniture method\"\"\" try : if furniture in [ \"SmallChair\" , \"MediumChair\" , \"BigChair\" ]: return ChairFactory () . get_chair ( furniture ) if furniture in [ \"SmallTable\" , \"MediumTable\" , \"BigTable\" ]: return TableFactory () . get_table ( furniture ) raise AssertionError ( \"No Furniture Factory Found\" ) except AssertionError as _e : print ( _e ) return None FURNITURE = FurnitureFactory . get_furniture ( \"SmallChair\" ) print ( f \"{FURNITURE.__class__} : {FURNITURE.dimensions()}\" ) FURNITURE = FurnitureFactory . get_furniture ( \"MediumTable\" ) print ( f \"{FURNITURE.__class__} : {FURNITURE.dimensions()}\" )","title":"furniture_abstract_factory.py"},{"location":"adapter/","text":"Adapter Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Adapter Design Pattern Description The adapter design pattern solves these problems: How can a class be reused that does not have an interface that a client requires? How can classes that have incompatible interfaces work together? How can an alternative interface be provided for a class? In this lecture, I have 2 classes, they don't share the same interface. The client requires it's objects to use an already standardised interface. So we need to create an adapter, that wraps the incompatible object, but implements the standardised interface. Two Incompatible Classes After Creating an Adapter Source Code adapter.py from abc import ABCMeta , abstractmethod class IA ( metaclass = ABCMeta ): @staticmethod @abstractmethod def method_a (): \"\"\"An abstract method A\"\"\" class ClassA ( IA ): def method_a ( self ): print ( \"method A\" ) class IB ( metaclass = ABCMeta ): @staticmethod @abstractmethod def method_b (): \"\"\"An abstract method B\"\"\" class ClassB ( IB ): def method_b ( self ): print ( \"method B\" ) \"\"\"ClassB does not have a method_a, so we create an adapter\"\"\" class ClassBAdapter ( IA ): def __init__ ( self ): self . class_b = ClassB () def method_a ( self ): \"\"\"calls the class b method_b instead\"\"\" self . class_b . method_b () # client #ITEM = ClassA() #ITEM = ClassB() # has no method_a ITEM = ClassBAdapter () ITEM . method_a ()","title":"Adapter"},{"location":"adapter/#adapter-design-pattern","text":"","title":"Adapter Design Pattern"},{"location":"adapter/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Adapter Design Pattern","title":"Video Lecture"},{"location":"adapter/#description","text":"The adapter design pattern solves these problems: How can a class be reused that does not have an interface that a client requires? How can classes that have incompatible interfaces work together? How can an alternative interface be provided for a class? In this lecture, I have 2 classes, they don't share the same interface. The client requires it's objects to use an already standardised interface. So we need to create an adapter, that wraps the incompatible object, but implements the standardised interface.","title":"Description"},{"location":"adapter/#two-incompatible-classes","text":"","title":"Two Incompatible Classes"},{"location":"adapter/#after-creating-an-adapter","text":"","title":"After Creating an Adapter"},{"location":"adapter/#source-code","text":"","title":"Source Code"},{"location":"adapter/#adapterpy","text":"from abc import ABCMeta , abstractmethod class IA ( metaclass = ABCMeta ): @staticmethod @abstractmethod def method_a (): \"\"\"An abstract method A\"\"\" class ClassA ( IA ): def method_a ( self ): print ( \"method A\" ) class IB ( metaclass = ABCMeta ): @staticmethod @abstractmethod def method_b (): \"\"\"An abstract method B\"\"\" class ClassB ( IB ): def method_b ( self ): print ( \"method B\" ) \"\"\"ClassB does not have a method_a, so we create an adapter\"\"\" class ClassBAdapter ( IA ): def __init__ ( self ): self . class_b = ClassB () def method_a ( self ): \"\"\"calls the class b method_b instead\"\"\" self . class_b . method_b () # client #ITEM = ClassA() #ITEM = ClassB() # has no method_a ITEM = ClassBAdapter () ITEM . method_a ()","title":"adapter.py"},{"location":"builder/","text":"Builder Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Builder Design Pattern Description The Builder Pattern is a creational pattern whose intent is to separate the construction of a complex object from its representation so that you can use the same construction process to create different representations. The Builder Pattern tries to solve, How can a class create different representations of a complex object? How can a class that includes creating a complex object be simplified? The Builder and Factory patterns are very similar in the fact they both instantiate new objects at run time. The difference is when the process of creating the object is more complex, so rather than the Factory returning a new instance of ObjectA , it could call the builders director construct method ObjectA.construct() . Both return an Object. Parts of the Builder Pattern Product - The Product being built Concrete Builder - Build the concrete product. Implements the IBuilder interface Builder Interface - The Interface which the Concrete builder should implement Director - Has a construct method which when called creates a customised product The Builder Pattern in the context of a House Builder. There are multiple directors creating there own complex objects . Source Code builder.py from abc import ABCMeta , abstractstaticmethod class IHouseBuilder ( metaclass = ABCMeta ): \"\"\"The Builder Interface\"\"\" @abstractstaticmethod def set_wall_material ( value ): \"\"\"Set the wall_material\"\"\" @abstractstaticmethod def set_building_type ( value ): \"\"\"Set the building_type\"\"\" @abstractstaticmethod def set_number_doors ( value ): \"\"\"Set the number of doors\"\"\" @abstractstaticmethod def set_number_windows ( value ): \"\"\"Set the number of windows\"\"\" @abstractstaticmethod def get_result (): \"\"\"Return the house\"\"\" class HouseBuilder ( IHouseBuilder ): \"\"\"The Concrete Builder.\"\"\" def __init__ ( self ): self . house = House () def set_wall_material ( self , value ): self . house . wall_material = value return self def set_building_type ( self , value ): self . house . building_type = value return self def set_number_doors ( self , value ): self . house . doors = value return self def set_number_windows ( self , value ): self . house . windows = value return self def get_result ( self ): return self . house class House (): \"\"\"The Product\"\"\" def __init__ ( self , building_type = \"Apartment\" , doors = 0 , windows = 0 , wall_material = \"Brick\" ): #brick, wood, straw, ice self . wall_material = wall_material # Apartment, Bungalow, Caravan, Hut, Castle, Duplex, HouseBoat, Igloo self . building_type = building_type self . doors = doors self . windows = windows def __str__ ( self ): return \"This is a {0} {1} with {2} door(s) and {3} window(s).\" . format ( self . wall_material , self . building_type , self . doors , self . windows ) class IglooDirector : \"\"\"The Director, building a different representation.\"\"\" @staticmethod def construct (): return HouseBuilder () \\ . set_building_type ( \"Igloo\" ) \\ . set_wall_material ( \"Ice\" ) \\ . set_number_doors ( 1 ) \\ . set_number_windows ( 0 ) \\ . get_result () class HouseBoatDirector : \"\"\"The Director, building a different representation.\"\"\" @staticmethod def construct (): return HouseBuilder () \\ . set_building_type ( \"House Boat\" ) \\ . set_wall_material ( \"Wooden\" ) \\ . set_number_doors ( 6 ) \\ . set_number_windows ( 8 ) \\ . get_result () class CastleDirector : \"\"\"The Director, building a different representation.\"\"\" @staticmethod def construct (): return HouseBuilder () \\ . set_building_type ( \"Castle\" ) \\ . set_wall_material ( \"Granite\" ) \\ . set_number_doors ( 100 ) \\ . set_number_windows ( 200 ) . get_result () if __name__ == \"__main__\" : IGLOO = IglooDirector . construct () HOUSE_BOAT = HouseBoatDirector . construct () CASTLE = CastleDirector . construct () print ( IGLOO ) print ( HOUSE_BOAT ) print ( CASTLE )","title":"Builder"},{"location":"builder/#builder-design-pattern","text":"","title":"Builder Design Pattern"},{"location":"builder/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Builder Design Pattern","title":"Video Lecture"},{"location":"builder/#description","text":"The Builder Pattern is a creational pattern whose intent is to separate the construction of a complex object from its representation so that you can use the same construction process to create different representations. The Builder Pattern tries to solve, How can a class create different representations of a complex object? How can a class that includes creating a complex object be simplified? The Builder and Factory patterns are very similar in the fact they both instantiate new objects at run time. The difference is when the process of creating the object is more complex, so rather than the Factory returning a new instance of ObjectA , it could call the builders director construct method ObjectA.construct() . Both return an Object. Parts of the Builder Pattern Product - The Product being built Concrete Builder - Build the concrete product. Implements the IBuilder interface Builder Interface - The Interface which the Concrete builder should implement Director - Has a construct method which when called creates a customised product The Builder Pattern in the context of a House Builder. There are multiple directors creating there own complex objects .","title":"Description"},{"location":"builder/#source-code","text":"","title":"Source Code"},{"location":"builder/#builderpy","text":"from abc import ABCMeta , abstractstaticmethod class IHouseBuilder ( metaclass = ABCMeta ): \"\"\"The Builder Interface\"\"\" @abstractstaticmethod def set_wall_material ( value ): \"\"\"Set the wall_material\"\"\" @abstractstaticmethod def set_building_type ( value ): \"\"\"Set the building_type\"\"\" @abstractstaticmethod def set_number_doors ( value ): \"\"\"Set the number of doors\"\"\" @abstractstaticmethod def set_number_windows ( value ): \"\"\"Set the number of windows\"\"\" @abstractstaticmethod def get_result (): \"\"\"Return the house\"\"\" class HouseBuilder ( IHouseBuilder ): \"\"\"The Concrete Builder.\"\"\" def __init__ ( self ): self . house = House () def set_wall_material ( self , value ): self . house . wall_material = value return self def set_building_type ( self , value ): self . house . building_type = value return self def set_number_doors ( self , value ): self . house . doors = value return self def set_number_windows ( self , value ): self . house . windows = value return self def get_result ( self ): return self . house class House (): \"\"\"The Product\"\"\" def __init__ ( self , building_type = \"Apartment\" , doors = 0 , windows = 0 , wall_material = \"Brick\" ): #brick, wood, straw, ice self . wall_material = wall_material # Apartment, Bungalow, Caravan, Hut, Castle, Duplex, HouseBoat, Igloo self . building_type = building_type self . doors = doors self . windows = windows def __str__ ( self ): return \"This is a {0} {1} with {2} door(s) and {3} window(s).\" . format ( self . wall_material , self . building_type , self . doors , self . windows ) class IglooDirector : \"\"\"The Director, building a different representation.\"\"\" @staticmethod def construct (): return HouseBuilder () \\ . set_building_type ( \"Igloo\" ) \\ . set_wall_material ( \"Ice\" ) \\ . set_number_doors ( 1 ) \\ . set_number_windows ( 0 ) \\ . get_result () class HouseBoatDirector : \"\"\"The Director, building a different representation.\"\"\" @staticmethod def construct (): return HouseBuilder () \\ . set_building_type ( \"House Boat\" ) \\ . set_wall_material ( \"Wooden\" ) \\ . set_number_doors ( 6 ) \\ . set_number_windows ( 8 ) \\ . get_result () class CastleDirector : \"\"\"The Director, building a different representation.\"\"\" @staticmethod def construct (): return HouseBuilder () \\ . set_building_type ( \"Castle\" ) \\ . set_wall_material ( \"Granite\" ) \\ . set_number_doors ( 100 ) \\ . set_number_windows ( 200 ) . get_result () if __name__ == \"__main__\" : IGLOO = IglooDirector . construct () HOUSE_BOAT = HouseBoatDirector . construct () CASTLE = CastleDirector . construct () print ( IGLOO ) print ( HOUSE_BOAT ) print ( CASTLE )","title":"builder.py"},{"location":"chain_of_responsibility/","text":"Chain of Responsibility Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Chain of Responsibility Design Pattern Description Chain of responsibility pattern is a behavioural pattern used to achieve loose coupling in software design. In this example, a request from a client is passed to a chain of objects to process them. The objects in the chain will decide how to process them and/or pass them to the next in the chain. The objects can also modify the next in the chain if for example you wanted to run objects in a recursive manner. Chain of Responsibility Diagram Chain of Responsibility UML Diagram in the context of an ATM In the ATM example, the chain is created to dispense an amount of \u00a350, then \u00a320s and then \u00a310s in order. The successor chain is hard coded in the chain client. def __init__ ( self ): # initialize the successor chain self . chain1 = Dispenser50 () self . chain2 = Dispenser20 () self . chain3 = Dispenser10 () # set the chain of responsibility # The Client may compose chains once or # the handler can set them dynamically at # handle time self . chain1 . set_successor ( self . chain2 ) self . chain2 . set_successor ( self . chain3 ) You also have the option to set the next successor on logic at handle time. Output $ python atm.py Enter amount to withdrawal 130 Dispensing 2 \u00a350 note Dispensing 1 \u00a320 note Dispensing 1 \u00a310 note Go spoil yourself Source Code atm.py from abc import ABCMeta , abstractstaticmethod class IHandler ( metaclass = ABCMeta ): @abstractstaticmethod def set_successor ( successor ): \"\"\"Set the next handler in the chain\"\"\" @abstractstaticmethod def handle ( amount ): \"\"\"Handle the event\"\"\" class Dispenser50 ( IHandler ): \"\"\"ConcreteHandler Dispense \u00a350 notes if applicable, otherwise continue to successor \"\"\" def __init__ ( self ): self . _successor = None def set_successor ( self , successor ): \"\"\"Set the successor\"\"\" self . _successor = successor def handle ( self , amount ): \"\"\"Handle the dispensing of notes\"\"\" if amount >= 50 : num = amount // 50 remainder = amount % 50 print ( f \"Dispensing {num} \u00a350 note\" ) if remainder != 0 : self . _successor . handle ( remainder ) else : self . _successor . handle ( amount ) class Dispenser20 ( IHandler ): \"\"\"ConcreteHandler Dispense \u00a320 notes if applicable, otherwise continue to successor \"\"\" def __init__ ( self ): self . _successor = None def set_successor ( self , successor ): \"\"\"Set the successor\"\"\" self . _successor = successor def handle ( self , amount ): \"\"\"Handle the dispensing of notes\"\"\" if amount >= 20 : num = amount // 20 remainder = amount % 20 print ( f \"Dispensing {num} \u00a320 note\" ) if remainder != 0 : self . _successor . handle ( remainder ) else : self . _successor . handle ( amount ) class Dispenser10 ( IHandler ): \"\"\"ConcreteHandler Dispense \u00a310 notes if applicable, otherwise continue to successor \"\"\" def __init__ ( self ): self . _successor = None def set_successor ( self , successor ): \"\"\"Set the successor\"\"\" self . _successor = successor def handle ( self , amount ): \"\"\"Handle the dispensing of notes\"\"\" if amount >= 10 : num = amount // 10 remainder = amount % 10 print ( f \"Dispensing {num} \u00a310 note\" ) if remainder != 0 : self . _successor . handle ( remainder ) else : self . _successor . handle ( amount ) class ATMDispenserChain : # pylint: disable=too-few-public-methods \"\"\"The Chain Client\"\"\" def __init__ ( self ): # initialize the successor chain self . chain1 = Dispenser50 () self . chain2 = Dispenser20 () self . chain3 = Dispenser10 () # set the chain of responsibility # The Client may compose chains once or # the hadler can set them dynamically at # handle time self . chain1 . set_successor ( self . chain2 ) self . chain2 . set_successor ( self . chain3 ) if __name__ == \"__main__\" : ATM = ATMDispenserChain () AMOUNT = int ( input ( \"Enter amount to withdrawal : \" )) if AMOUNT < 10 or AMOUNT % 10 != 0 : print ( \"Amount should be positive and in multiple of 10s.\" ) exit () # process the request ATM . chain1 . handle ( AMOUNT ) print ( \"Now go spoil yourself\" )","title":"Chain of Responsibility"},{"location":"chain_of_responsibility/#chain-of-responsibility-design-pattern","text":"","title":"Chain of Responsibility Design Pattern"},{"location":"chain_of_responsibility/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Chain of Responsibility Design Pattern","title":"Video Lecture"},{"location":"chain_of_responsibility/#description","text":"Chain of responsibility pattern is a behavioural pattern used to achieve loose coupling in software design. In this example, a request from a client is passed to a chain of objects to process them. The objects in the chain will decide how to process them and/or pass them to the next in the chain. The objects can also modify the next in the chain if for example you wanted to run objects in a recursive manner.","title":"Description"},{"location":"chain_of_responsibility/#chain-of-responsibility-diagram","text":"","title":"Chain of Responsibility Diagram"},{"location":"chain_of_responsibility/#chain-of-responsibility-uml-diagram-in-the-context-of-an-atm","text":"In the ATM example, the chain is created to dispense an amount of \u00a350, then \u00a320s and then \u00a310s in order. The successor chain is hard coded in the chain client. def __init__ ( self ): # initialize the successor chain self . chain1 = Dispenser50 () self . chain2 = Dispenser20 () self . chain3 = Dispenser10 () # set the chain of responsibility # The Client may compose chains once or # the handler can set them dynamically at # handle time self . chain1 . set_successor ( self . chain2 ) self . chain2 . set_successor ( self . chain3 ) You also have the option to set the next successor on logic at handle time.","title":"Chain of Responsibility UML Diagram in the context of an ATM"},{"location":"chain_of_responsibility/#output","text":"$ python atm.py Enter amount to withdrawal 130 Dispensing 2 \u00a350 note Dispensing 1 \u00a320 note Dispensing 1 \u00a310 note Go spoil yourself","title":"Output"},{"location":"chain_of_responsibility/#source-code","text":"","title":"Source Code"},{"location":"chain_of_responsibility/#atmpy","text":"from abc import ABCMeta , abstractstaticmethod class IHandler ( metaclass = ABCMeta ): @abstractstaticmethod def set_successor ( successor ): \"\"\"Set the next handler in the chain\"\"\" @abstractstaticmethod def handle ( amount ): \"\"\"Handle the event\"\"\" class Dispenser50 ( IHandler ): \"\"\"ConcreteHandler Dispense \u00a350 notes if applicable, otherwise continue to successor \"\"\" def __init__ ( self ): self . _successor = None def set_successor ( self , successor ): \"\"\"Set the successor\"\"\" self . _successor = successor def handle ( self , amount ): \"\"\"Handle the dispensing of notes\"\"\" if amount >= 50 : num = amount // 50 remainder = amount % 50 print ( f \"Dispensing {num} \u00a350 note\" ) if remainder != 0 : self . _successor . handle ( remainder ) else : self . _successor . handle ( amount ) class Dispenser20 ( IHandler ): \"\"\"ConcreteHandler Dispense \u00a320 notes if applicable, otherwise continue to successor \"\"\" def __init__ ( self ): self . _successor = None def set_successor ( self , successor ): \"\"\"Set the successor\"\"\" self . _successor = successor def handle ( self , amount ): \"\"\"Handle the dispensing of notes\"\"\" if amount >= 20 : num = amount // 20 remainder = amount % 20 print ( f \"Dispensing {num} \u00a320 note\" ) if remainder != 0 : self . _successor . handle ( remainder ) else : self . _successor . handle ( amount ) class Dispenser10 ( IHandler ): \"\"\"ConcreteHandler Dispense \u00a310 notes if applicable, otherwise continue to successor \"\"\" def __init__ ( self ): self . _successor = None def set_successor ( self , successor ): \"\"\"Set the successor\"\"\" self . _successor = successor def handle ( self , amount ): \"\"\"Handle the dispensing of notes\"\"\" if amount >= 10 : num = amount // 10 remainder = amount % 10 print ( f \"Dispensing {num} \u00a310 note\" ) if remainder != 0 : self . _successor . handle ( remainder ) else : self . _successor . handle ( amount ) class ATMDispenserChain : # pylint: disable=too-few-public-methods \"\"\"The Chain Client\"\"\" def __init__ ( self ): # initialize the successor chain self . chain1 = Dispenser50 () self . chain2 = Dispenser20 () self . chain3 = Dispenser10 () # set the chain of responsibility # The Client may compose chains once or # the hadler can set them dynamically at # handle time self . chain1 . set_successor ( self . chain2 ) self . chain2 . set_successor ( self . chain3 ) if __name__ == \"__main__\" : ATM = ATMDispenserChain () AMOUNT = int ( input ( \"Enter amount to withdrawal : \" )) if AMOUNT < 10 or AMOUNT % 10 != 0 : print ( \"Amount should be positive and in multiple of 10s.\" ) exit () # process the request ATM . chain1 . handle ( AMOUNT ) print ( \"Now go spoil yourself\" )","title":"atm.py"},{"location":"command/","text":"Command Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Command Design Pattern Description The command pattern is a behavioural design pattern, in which an abstraction exists between an object that invokes a command, and the object that performs it. The components of the Command Design Pattern are, Receiver : The Object that will receive and execute the command Invoker : Which will send the command to the receiver Command Object : Itself, which implements an execute, or action method, and contains all required information to execute it Client : The application or component which is aware of the Receiver, Invoker and Commands Eg, a button, will call the Invoker, which will call a pre registered Commands execute method, which the Receiver will perform. A Concrete Class will delegate a request to a command object, instead of implementing the request directly. Using a command design pattern allows you to separate concerns a little easier and to solve problems of the concerns independently of each of the layers. eg, logging the execution of a command and it's outcome. Uses: GUI Buttons, menus Macro recording Multi level undo/redo Networking - send whole command objects across a network, even as a batch Parallel processing or thread pools Transactional behaviour Wizards Notes: The receiver object should manages it's own state, not the command object There can be one or more invokers which can execute the command at a later date. The Command Pattern in the context of a light switch Source Code switch_command.py from abc import ABCMeta , abstractstaticmethod import time class ICommand ( metaclass = ABCMeta ): \"\"\"The command interface, which all commands will implement\"\"\" @abstractstaticmethod def execute (): \"\"\"The required execute method which all command objects will use\"\"\" class Switch : \"\"\"The Invoker Class\"\"\" def __init__ ( self ): self . _commands = {} self . _history = [] @property def history ( self ): return self . _history def register ( self , command_name , command ): self . _commands [ command_name ] = command def execute ( self , command_name ): if command_name in self . _commands . keys (): self . _history . append (( time . time (), command_name )) self . _commands [ command_name ] . execute () else : print ( f \"Command [{command_name}] not recognised\" ) class Light : \"\"\"The Receiver\"\"\" def turn_on ( self ): print ( \"Light turned ON\" ) def turn_off ( self ): print ( \"Light turned OFF\" ) class SwitchOnCommand ( ICommand ): \"\"\"A Command object, which implements the ICommand interface\"\"\" def __init__ ( self , light ): self . _light = light def execute ( self ): self . _light . turn_on () class SwitchOffCommand ( ICommand ): \"\"\"A Command object, which implements the ICommand interface\"\"\" def __init__ ( self , light ): self . _light = light def execute ( self ): self . _light . turn_off () if __name__ == \"__main__\" : # The Client is the main python app # The Light is the Receiver LIGHT = Light () # Create Commands SWITCH_ON = SwitchOnCommand ( LIGHT ) SWITCH_OFF = SwitchOffCommand ( LIGHT ) # Register the commands with the invoker (Switch) SWITCH = Switch () SWITCH . register ( \"ON\" , SWITCH_ON ) SWITCH . register ( \"OFF\" , SWITCH_OFF ) # Execute the commands that are registered on the Invoker SWITCH . execute ( \"ON\" ) SWITCH . execute ( \"OFF\" ) SWITCH . execute ( \"ON\" ) SWITCH . execute ( \"OFF\" ) # For fun, we can see the history print ( SWITCH . history )","title":"Command"},{"location":"command/#command-design-pattern","text":"","title":"Command Design Pattern"},{"location":"command/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Command Design Pattern","title":"Video Lecture"},{"location":"command/#description","text":"The command pattern is a behavioural design pattern, in which an abstraction exists between an object that invokes a command, and the object that performs it. The components of the Command Design Pattern are, Receiver : The Object that will receive and execute the command Invoker : Which will send the command to the receiver Command Object : Itself, which implements an execute, or action method, and contains all required information to execute it Client : The application or component which is aware of the Receiver, Invoker and Commands Eg, a button, will call the Invoker, which will call a pre registered Commands execute method, which the Receiver will perform. A Concrete Class will delegate a request to a command object, instead of implementing the request directly. Using a command design pattern allows you to separate concerns a little easier and to solve problems of the concerns independently of each of the layers. eg, logging the execution of a command and it's outcome. Uses: GUI Buttons, menus Macro recording Multi level undo/redo Networking - send whole command objects across a network, even as a batch Parallel processing or thread pools Transactional behaviour Wizards Notes: The receiver object should manages it's own state, not the command object There can be one or more invokers which can execute the command at a later date. The Command Pattern in the context of a light switch","title":"Description"},{"location":"command/#source-code","text":"","title":"Source Code"},{"location":"command/#switch_commandpy","text":"from abc import ABCMeta , abstractstaticmethod import time class ICommand ( metaclass = ABCMeta ): \"\"\"The command interface, which all commands will implement\"\"\" @abstractstaticmethod def execute (): \"\"\"The required execute method which all command objects will use\"\"\" class Switch : \"\"\"The Invoker Class\"\"\" def __init__ ( self ): self . _commands = {} self . _history = [] @property def history ( self ): return self . _history def register ( self , command_name , command ): self . _commands [ command_name ] = command def execute ( self , command_name ): if command_name in self . _commands . keys (): self . _history . append (( time . time (), command_name )) self . _commands [ command_name ] . execute () else : print ( f \"Command [{command_name}] not recognised\" ) class Light : \"\"\"The Receiver\"\"\" def turn_on ( self ): print ( \"Light turned ON\" ) def turn_off ( self ): print ( \"Light turned OFF\" ) class SwitchOnCommand ( ICommand ): \"\"\"A Command object, which implements the ICommand interface\"\"\" def __init__ ( self , light ): self . _light = light def execute ( self ): self . _light . turn_on () class SwitchOffCommand ( ICommand ): \"\"\"A Command object, which implements the ICommand interface\"\"\" def __init__ ( self , light ): self . _light = light def execute ( self ): self . _light . turn_off () if __name__ == \"__main__\" : # The Client is the main python app # The Light is the Receiver LIGHT = Light () # Create Commands SWITCH_ON = SwitchOnCommand ( LIGHT ) SWITCH_OFF = SwitchOffCommand ( LIGHT ) # Register the commands with the invoker (Switch) SWITCH = Switch () SWITCH . register ( \"ON\" , SWITCH_ON ) SWITCH . register ( \"OFF\" , SWITCH_OFF ) # Execute the commands that are registered on the Invoker SWITCH . execute ( \"ON\" ) SWITCH . execute ( \"OFF\" ) SWITCH . execute ( \"ON\" ) SWITCH . execute ( \"OFF\" ) # For fun, we can see the history print ( SWITCH . history )","title":"switch_command.py"},{"location":"command_undo_redo/","text":"Command Design Pattern (Undo/Redo) Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Command (Undo/Redo) Design Pattern Description This is part 2 of the Command Design Pattern tutorial, where I create a slider, instead of the switch from part 1. The slider also accepts a variable percentage, rather than an ON/OFF. The history also records the variable setting. And I also add UNDO/REDO to the Invoker so that you can go backwards and forwards through time. Source Code slider_command.py from abc import ABCMeta , abstractstaticmethod import time class ICommand ( metaclass = ABCMeta ): \"\"\"The command interface, which all commands will implement\"\"\" @abstractstaticmethod def execute ( * args ): \"\"\"The required execute method which all command obejcts will use\"\"\" class IUndoRedo ( metaclass = ABCMeta ): \"\"\"The Undo Redo interface\"\"\" @abstractstaticmethod def history (): \"\"\"the history of the states\"\"\" @abstractstaticmethod def undo (): \"\"\"for undoing the hsitory of the states\"\"\" @abstractstaticmethod def redo (): \"\"\"for redoing the hsitory of the states\"\"\" class Slider ( IUndoRedo ): \"\"\"The Invoker Class\"\"\" def __init__ ( self ): self . _commands = {} self . _history = [( 0.0 , \"OFF\" , ())] # A default setting of OFF self . _history_position = 0 # The position that is used for UNDO/REDO @property def history ( self ): \"\"\"Return all records in the History list\"\"\" return self . _history def register ( self , command_name , command ): \"\"\"All commands are registered in the Invoker Class\"\"\" self . _commands [ command_name ] = command def execute ( self , command_name , * args ): \"\"\"Execute a pre defined command and log in history\"\"\" if command_name in self . _commands . keys (): self . _history_position += 1 self . _commands [ command_name ] . execute ( args ) if len ( self . _history ) == self . _history_position : # This is a new event in hisory self . _history . append (( time . time (), command_name , args )) else : # This occurs if there was one of more UNDOs and then a new # execute command happened. In case of UNDO, the history_position # changes, and executing new commands purges any history after # the current position\"\"\" self . _history = self . _history [: self . _history_position + 1 ] self . _history [ self . _history_position ] = { time . time (): [ command_name , args ] } else : print ( f \"Command [{command_name}] not recognised\" ) def undo ( self ): \"\"\"Undo a command if there is a command that can be undone. Update the history position so that further UNDOs or REDOs point to the correct index\"\"\" if self . _history_position > 0 : self . _history_position -= 1 self . _commands [ self . _history [ self . _history_position ][ 1 ] ] . execute ( self . _history [ self . _history_position ][ 2 ]) else : print ( \"nothing to undo\" ) def redo ( self ): \"\"\"Perform a REDO if the history_position is less than the end of the history list\"\"\" if self . _history_position + 1 < len ( self . _history ): self . _history_position += 1 self . _commands [ self . _history [ self . _history_position ][ 1 ] ] . execute ( self . _history [ self . _history_position ][ 2 ]) else : print ( \"nothing to REDO\" ) class Heater : \"\"\"The Receiver\"\"\" def set_to_max ( self ): print ( \"Heater is ON and set to MAX (100%)\" ) def set_to_percent ( self , * args ): print ( f \"Heater is ON and set to {args[0][0]}%\" ) def turn_off ( self ): print ( \"Heater is OFF\" ) class SliderMaxCommand ( ICommand ): \"\"\"A Command object, which implements the ICommand interface\"\"\" def __init__ ( self , heater ): self . _heater = heater def execute ( self , * args ): self . _heater . set_to_max () class SliderPercentCommand ( ICommand ): \"\"\"A Command object, which implements the ICommand interface\"\"\" def __init__ ( self , heater ): self . _heater = heater def execute ( self , * args ): self . _heater . set_to_percent ( args [ 0 ]) class SliderOffCommand ( ICommand ): \"\"\"A Command object, which implements the ICommand interface\"\"\" def __init__ ( self , heater ): self . _heater = heater def execute ( self , * args ): self . _heater . turn_off () if __name__ == \"__main__\" : # The Client is the main python app # The HEATER is the Receiver HEATER = Heater () # Create Commands SLIDER_MAX = SliderMaxCommand ( HEATER ) SLIDER_PERCENT = SliderPercentCommand ( HEATER ) SLIDER_OFF = SliderOffCommand ( HEATER ) # Register the commands with the invoker (Switch) SLIDER = Slider () SLIDER . register ( \"MAX\" , SLIDER_MAX ) SLIDER . register ( \"PERCENT\" , SLIDER_PERCENT ) SLIDER . register ( \"OFF\" , SLIDER_OFF ) # Execute the commands that are registered on the Invoker SLIDER . execute ( \"PERCENT\" , 10 ) SLIDER . execute ( \"PERCENT\" , 20 ) SLIDER . execute ( \"PERCENT\" , 30 ) SLIDER . execute ( \"PERCENT\" , 40 ) SLIDER . execute ( \"PERCENT\" , 50 ) print ( SLIDER . history ) SLIDER . undo () SLIDER . undo () SLIDER . undo () SLIDER . redo () SLIDER . undo () SLIDER . undo () SLIDER . execute ( \"PERCENT\" , 90 ) SLIDER . execute ( \"MAX\" ) SLIDER . execute ( \"OFF\" ) print ( SLIDER . history ) SLIDER . undo () SLIDER . redo () print ( SLIDER . history )","title":"Command Undo/Redo"},{"location":"command_undo_redo/#command-design-pattern-undoredo","text":"","title":"Command Design Pattern (Undo/Redo)"},{"location":"command_undo_redo/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Command (Undo/Redo) Design Pattern","title":"Video Lecture"},{"location":"command_undo_redo/#description","text":"This is part 2 of the Command Design Pattern tutorial, where I create a slider, instead of the switch from part 1. The slider also accepts a variable percentage, rather than an ON/OFF. The history also records the variable setting. And I also add UNDO/REDO to the Invoker so that you can go backwards and forwards through time.","title":"Description"},{"location":"command_undo_redo/#source-code","text":"","title":"Source Code"},{"location":"command_undo_redo/#slider_commandpy","text":"from abc import ABCMeta , abstractstaticmethod import time class ICommand ( metaclass = ABCMeta ): \"\"\"The command interface, which all commands will implement\"\"\" @abstractstaticmethod def execute ( * args ): \"\"\"The required execute method which all command obejcts will use\"\"\" class IUndoRedo ( metaclass = ABCMeta ): \"\"\"The Undo Redo interface\"\"\" @abstractstaticmethod def history (): \"\"\"the history of the states\"\"\" @abstractstaticmethod def undo (): \"\"\"for undoing the hsitory of the states\"\"\" @abstractstaticmethod def redo (): \"\"\"for redoing the hsitory of the states\"\"\" class Slider ( IUndoRedo ): \"\"\"The Invoker Class\"\"\" def __init__ ( self ): self . _commands = {} self . _history = [( 0.0 , \"OFF\" , ())] # A default setting of OFF self . _history_position = 0 # The position that is used for UNDO/REDO @property def history ( self ): \"\"\"Return all records in the History list\"\"\" return self . _history def register ( self , command_name , command ): \"\"\"All commands are registered in the Invoker Class\"\"\" self . _commands [ command_name ] = command def execute ( self , command_name , * args ): \"\"\"Execute a pre defined command and log in history\"\"\" if command_name in self . _commands . keys (): self . _history_position += 1 self . _commands [ command_name ] . execute ( args ) if len ( self . _history ) == self . _history_position : # This is a new event in hisory self . _history . append (( time . time (), command_name , args )) else : # This occurs if there was one of more UNDOs and then a new # execute command happened. In case of UNDO, the history_position # changes, and executing new commands purges any history after # the current position\"\"\" self . _history = self . _history [: self . _history_position + 1 ] self . _history [ self . _history_position ] = { time . time (): [ command_name , args ] } else : print ( f \"Command [{command_name}] not recognised\" ) def undo ( self ): \"\"\"Undo a command if there is a command that can be undone. Update the history position so that further UNDOs or REDOs point to the correct index\"\"\" if self . _history_position > 0 : self . _history_position -= 1 self . _commands [ self . _history [ self . _history_position ][ 1 ] ] . execute ( self . _history [ self . _history_position ][ 2 ]) else : print ( \"nothing to undo\" ) def redo ( self ): \"\"\"Perform a REDO if the history_position is less than the end of the history list\"\"\" if self . _history_position + 1 < len ( self . _history ): self . _history_position += 1 self . _commands [ self . _history [ self . _history_position ][ 1 ] ] . execute ( self . _history [ self . _history_position ][ 2 ]) else : print ( \"nothing to REDO\" ) class Heater : \"\"\"The Receiver\"\"\" def set_to_max ( self ): print ( \"Heater is ON and set to MAX (100%)\" ) def set_to_percent ( self , * args ): print ( f \"Heater is ON and set to {args[0][0]}%\" ) def turn_off ( self ): print ( \"Heater is OFF\" ) class SliderMaxCommand ( ICommand ): \"\"\"A Command object, which implements the ICommand interface\"\"\" def __init__ ( self , heater ): self . _heater = heater def execute ( self , * args ): self . _heater . set_to_max () class SliderPercentCommand ( ICommand ): \"\"\"A Command object, which implements the ICommand interface\"\"\" def __init__ ( self , heater ): self . _heater = heater def execute ( self , * args ): self . _heater . set_to_percent ( args [ 0 ]) class SliderOffCommand ( ICommand ): \"\"\"A Command object, which implements the ICommand interface\"\"\" def __init__ ( self , heater ): self . _heater = heater def execute ( self , * args ): self . _heater . turn_off () if __name__ == \"__main__\" : # The Client is the main python app # The HEATER is the Receiver HEATER = Heater () # Create Commands SLIDER_MAX = SliderMaxCommand ( HEATER ) SLIDER_PERCENT = SliderPercentCommand ( HEATER ) SLIDER_OFF = SliderOffCommand ( HEATER ) # Register the commands with the invoker (Switch) SLIDER = Slider () SLIDER . register ( \"MAX\" , SLIDER_MAX ) SLIDER . register ( \"PERCENT\" , SLIDER_PERCENT ) SLIDER . register ( \"OFF\" , SLIDER_OFF ) # Execute the commands that are registered on the Invoker SLIDER . execute ( \"PERCENT\" , 10 ) SLIDER . execute ( \"PERCENT\" , 20 ) SLIDER . execute ( \"PERCENT\" , 30 ) SLIDER . execute ( \"PERCENT\" , 40 ) SLIDER . execute ( \"PERCENT\" , 50 ) print ( SLIDER . history ) SLIDER . undo () SLIDER . undo () SLIDER . undo () SLIDER . redo () SLIDER . undo () SLIDER . undo () SLIDER . execute ( \"PERCENT\" , 90 ) SLIDER . execute ( \"MAX\" ) SLIDER . execute ( \"OFF\" ) print ( SLIDER . history ) SLIDER . undo () SLIDER . redo () print ( SLIDER . history )","title":"slider_command.py"},{"location":"composite/","text":"Composite Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Composite Design Pattern Description The Composite design pattern, - allows you to represent individual entities and groups of entities in the same manner. - is a structural design pattern that lets you compose objects into a tree. - is great if you need the option of swapping hierarchal relationships around. - makes it easier for you to add new kinds of components - provides flexibility of structure - conform to the Single Responsibility Principle in the way that it separates the aggregation of objects from the features of the object. Examples of using the Composite Design Pattern can be seen in a filesystem directory structure, where you can swap the hierarchy of folders, and in a drawing program where you can group, un-group and transform objects, and multiple objects at the same time. Source Code composite.py from abc import ABCMeta , abstractmethod class IGraphic ( metaclass = ABCMeta ): @staticmethod @abstractmethod def print (): \"\"\"print information\"\"\" class Ellipse ( IGraphic ): def print ( self ): print ( \"Ellipse\" ) class Circle ( IGraphic ): def print ( self ): print ( \"Circle\" ) class CompositeGraphic ( IGraphic ): def __init__ ( self ): self . child_graphics = [] def add ( self , graphic ): self . child_graphics . append ( graphic ) def print ( self ): for g in self . child_graphics : g . print () ELLIPSE1 = Ellipse () CIRCLE1 = Circle () COMPOSITE1 = CompositeGraphic () COMPOSITE1 . add ( ELLIPSE1 ) COMPOSITE2 = CompositeGraphic () COMPOSITE2 . add ( CIRCLE1 ) COMPOSITE2 . add ( COMPOSITE1 ) COMPOSITE2 . print () # ELLIPSE1.print() # CIRCLE1.print()","title":"Composite"},{"location":"composite/#composite-design-pattern","text":"","title":"Composite Design Pattern"},{"location":"composite/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Composite Design Pattern","title":"Video Lecture"},{"location":"composite/#description","text":"The Composite design pattern, - allows you to represent individual entities and groups of entities in the same manner. - is a structural design pattern that lets you compose objects into a tree. - is great if you need the option of swapping hierarchal relationships around. - makes it easier for you to add new kinds of components - provides flexibility of structure - conform to the Single Responsibility Principle in the way that it separates the aggregation of objects from the features of the object. Examples of using the Composite Design Pattern can be seen in a filesystem directory structure, where you can swap the hierarchy of folders, and in a drawing program where you can group, un-group and transform objects, and multiple objects at the same time.","title":"Description"},{"location":"composite/#source-code","text":"","title":"Source Code"},{"location":"composite/#compositepy","text":"from abc import ABCMeta , abstractmethod class IGraphic ( metaclass = ABCMeta ): @staticmethod @abstractmethod def print (): \"\"\"print information\"\"\" class Ellipse ( IGraphic ): def print ( self ): print ( \"Ellipse\" ) class Circle ( IGraphic ): def print ( self ): print ( \"Circle\" ) class CompositeGraphic ( IGraphic ): def __init__ ( self ): self . child_graphics = [] def add ( self , graphic ): self . child_graphics . append ( graphic ) def print ( self ): for g in self . child_graphics : g . print () ELLIPSE1 = Ellipse () CIRCLE1 = Circle () COMPOSITE1 = CompositeGraphic () COMPOSITE1 . add ( ELLIPSE1 ) COMPOSITE2 = CompositeGraphic () COMPOSITE2 . add ( CIRCLE1 ) COMPOSITE2 . add ( COMPOSITE1 ) COMPOSITE2 . print () # ELLIPSE1.print() # CIRCLE1.print()","title":"composite.py"},{"location":"decorator/","text":"Decorator Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Decorator Design Pattern Description The decorator pattern is a structural pattern, that allows you to attach additional responsibilities to an object at run time. The decorator pattern is used in both the Object Oriented and Functional paradigms. The decorator pattern is different than the Python language feature of Python Decorators in it's syntax, but the application of it is the same, in the way that it is essentially a wrapper. The Decorator pattern adds extensibility, without modifying the original function. Source Code decorator.py class UndecoratedObject : @staticmethod def get (): return \"UndecoratedObject\" class Decorate : def __init__ ( self , undecorated ): self . undecorated = undecorated def get ( self ): return self . undecorated . get () . replace ( \"Undecorated\" , \"Decorated\" ) # class DecorateWithANewMethod: # def __init__(self, undecorated): # self.undecorated = undecorated # def get(self): # return self.undecorated.get() # def draw(self): # print(self.undecorated.get()) UNDECORATED = UndecoratedObject () print ( UNDECORATED . get ()) DECORATED = Decorate ( UNDECORATED ) print ( DECORATED . get ()) #DECORATEDWITHNEWMETHOD = DecorateWithANewMethod(DECORATED) #DECORATEDWITHNEWMETHOD.draw()","title":"Decorator"},{"location":"decorator/#decorator-design-pattern","text":"","title":"Decorator Design Pattern"},{"location":"decorator/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Decorator Design Pattern","title":"Video Lecture"},{"location":"decorator/#description","text":"The decorator pattern is a structural pattern, that allows you to attach additional responsibilities to an object at run time. The decorator pattern is used in both the Object Oriented and Functional paradigms. The decorator pattern is different than the Python language feature of Python Decorators in it's syntax, but the application of it is the same, in the way that it is essentially a wrapper. The Decorator pattern adds extensibility, without modifying the original function.","title":"Description"},{"location":"decorator/#source-code","text":"","title":"Source Code"},{"location":"decorator/#decoratorpy","text":"class UndecoratedObject : @staticmethod def get (): return \"UndecoratedObject\" class Decorate : def __init__ ( self , undecorated ): self . undecorated = undecorated def get ( self ): return self . undecorated . get () . replace ( \"Undecorated\" , \"Decorated\" ) # class DecorateWithANewMethod: # def __init__(self, undecorated): # self.undecorated = undecorated # def get(self): # return self.undecorated.get() # def draw(self): # print(self.undecorated.get()) UNDECORATED = UndecoratedObject () print ( UNDECORATED . get ()) DECORATED = Decorate ( UNDECORATED ) print ( DECORATED . get ()) #DECORATEDWITHNEWMETHOD = DecorateWithANewMethod(DECORATED) #DECORATEDWITHNEWMETHOD.draw()","title":"decorator.py"},{"location":"facade/","text":"Facade Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Facade Design Pattern Description The Facade Pattern is a structural design pattern. It provides a simplified interface to a set of other interfaces, abstractions and implementations within a system that may be full of complexity and/or tightly coupled. Source Code facade.py class SubSystemClassA : @staticmethod def method (): return \"A\" class SubSystemClassB : @staticmethod def method (): return \"B\" class SubSystemClassC : @staticmethod def method (): return \"C\" # facade class Facade : def __init__ ( self ): self . sub_system_class_a = SubSystemClassA () self . sub_system_class_b = SubSystemClassB () self . sub_system_class_c = SubSystemClassC () def create ( self ): result = self . sub_system_class_a . method () result += self . sub_system_class_b . method () result += self . sub_system_class_c . method () return result # client FACADE = Facade () RESULT = FACADE . create () print ( \"The Result = %s \" % RESULT )","title":"Facade"},{"location":"facade/#facade-design-pattern","text":"","title":"Facade Design Pattern"},{"location":"facade/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Facade Design Pattern","title":"Video Lecture"},{"location":"facade/#description","text":"The Facade Pattern is a structural design pattern. It provides a simplified interface to a set of other interfaces, abstractions and implementations within a system that may be full of complexity and/or tightly coupled.","title":"Description"},{"location":"facade/#source-code","text":"","title":"Source Code"},{"location":"facade/#facadepy","text":"class SubSystemClassA : @staticmethod def method (): return \"A\" class SubSystemClassB : @staticmethod def method (): return \"B\" class SubSystemClassC : @staticmethod def method (): return \"C\" # facade class Facade : def __init__ ( self ): self . sub_system_class_a = SubSystemClassA () self . sub_system_class_b = SubSystemClassB () self . sub_system_class_c = SubSystemClassC () def create ( self ): result = self . sub_system_class_a . method () result += self . sub_system_class_b . method () result += self . sub_system_class_c . method () return result # client FACADE = Facade () RESULT = FACADE . create () print ( \"The Result = %s \" % RESULT )","title":"facade.py"},{"location":"factory/","text":"Factory Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Factory Design Pattern Description The Factory Pattern is a creational pattern that defines an Interface for creating an object and defers instantiation until runtime. Used when you don't know how many or what type of objects will be needed until or during runtime The Factory Pattern in the context of a Chair Factory Source Code chair_factory.py from abc import ABCMeta , abstractstaticmethod class IChair ( metaclass = ABCMeta ): # pylint: disable=too-few-public-methods \"\"\"The Chair Interface\"\"\" @abstractstaticmethod def dimensions (): \"\"\"A static inteface method\"\"\" class BigChair ( IChair ): # pylint: disable=too-few-public-methods \"\"\"The Big Chair Concrete Class which implements the IChair interface\"\"\" def __init__ ( self ): self . _height = 80 self . _width = 80 self . _depth = 80 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class MediumChair ( IChair ): # pylint: disable=too-few-public-methods \"\"\"The Medium Chair Concrete Class which implements the IChair interface\"\"\" def __init__ ( self ): self . _height = 60 self . _width = 60 self . _depth = 60 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class SmallChair ( IChair ): # pylint: disable=too-few-public-methods \"\"\"The Small Chair Concrete Class which implements the IChair interface\"\"\" def __init__ ( self ): self . _height = 40 self . _width = 40 self . _depth = 40 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class ChairFactory : # pylint: disable=too-few-public-methods \"\"\"Tha Factory Class\"\"\" @staticmethod def get_chair ( chair ): \"\"\"A static method to get a table\"\"\" try : if chair == \"BigChair\" : return BigChair () if chair == \"MediumChair\" : return MediumChair () if chair == \"SmallChair\" : return SmallChair () raise AssertionError ( \"Chair Not Found\" ) except AssertionError as _e : print ( _e ) return None if __name__ == \"__main__\" : CHAIR_FACTORY = ChairFactory () . get_chair ( \"SmallChair\" ) print ( CHAIR_FACTORY . dimensions ())","title":"Factory"},{"location":"factory/#factory-design-pattern","text":"","title":"Factory Design Pattern"},{"location":"factory/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Factory Design Pattern","title":"Video Lecture"},{"location":"factory/#description","text":"The Factory Pattern is a creational pattern that defines an Interface for creating an object and defers instantiation until runtime. Used when you don't know how many or what type of objects will be needed until or during runtime The Factory Pattern in the context of a Chair Factory","title":"Description"},{"location":"factory/#source-code","text":"","title":"Source Code"},{"location":"factory/#chair_factorypy","text":"from abc import ABCMeta , abstractstaticmethod class IChair ( metaclass = ABCMeta ): # pylint: disable=too-few-public-methods \"\"\"The Chair Interface\"\"\" @abstractstaticmethod def dimensions (): \"\"\"A static inteface method\"\"\" class BigChair ( IChair ): # pylint: disable=too-few-public-methods \"\"\"The Big Chair Concrete Class which implements the IChair interface\"\"\" def __init__ ( self ): self . _height = 80 self . _width = 80 self . _depth = 80 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class MediumChair ( IChair ): # pylint: disable=too-few-public-methods \"\"\"The Medium Chair Concrete Class which implements the IChair interface\"\"\" def __init__ ( self ): self . _height = 60 self . _width = 60 self . _depth = 60 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class SmallChair ( IChair ): # pylint: disable=too-few-public-methods \"\"\"The Small Chair Concrete Class which implements the IChair interface\"\"\" def __init__ ( self ): self . _height = 40 self . _width = 40 self . _depth = 40 def dimensions ( self ): return { \"width\" : self . _width , \"depth\" : self . _depth , \"height\" : self . _height } class ChairFactory : # pylint: disable=too-few-public-methods \"\"\"Tha Factory Class\"\"\" @staticmethod def get_chair ( chair ): \"\"\"A static method to get a table\"\"\" try : if chair == \"BigChair\" : return BigChair () if chair == \"MediumChair\" : return MediumChair () if chair == \"SmallChair\" : return SmallChair () raise AssertionError ( \"Chair Not Found\" ) except AssertionError as _e : print ( _e ) return None if __name__ == \"__main__\" : CHAIR_FACTORY = ChairFactory () . get_chair ( \"SmallChair\" ) print ( CHAIR_FACTORY . dimensions ())","title":"chair_factory.py"},{"location":"iterator/","text":"Iterator Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Iterator Design Pattern Description An interface with next and has_next methods. next returns the next object in the aggregate(collection, list) has_next returns a value, usually a boolean indicating if the iterable is at the end of the list or not. The benefits of using the Iterator pattern is that the client, can traverse an aggregate without needing to understand it's internal representation and data structures. Source Code iterator.py from abc import ABCMeta , abstractmethod class IIterator ( metaclass = ABCMeta ): @staticmethod @abstractmethod def has_next (): \"\"\"Returns Boolean whether at end of collection or not\"\"\" @staticmethod @abstractmethod def next (): \"\"\"Return the object in collection\"\"\" class Iterable ( IIterator ): def __init__ ( self ): self . index = 0 self . maximum = 7 def next ( self ): if self . index < self . maximum : x = self . index self . index += 1 return x else : raise Exception ( \"AtEndOfIteratorException\" , \"At End of Iterator\" ) def has_next ( self ): return self . index < self . maximum ITERABLE = Iterable () while ITERABLE . has_next (): print ( ITERABLE . next ()) # print(ITERABLE.next()) # print(ITERABLE.next()) # print(ITERABLE.next()) # print(ITERABLE.next()) # print(ITERABLE.next()) # print(ITERABLE.next()) # print(ITERABLE.next()) # print(ITERABLE.next())","title":"Iterator"},{"location":"iterator/#iterator-design-pattern","text":"","title":"Iterator Design Pattern"},{"location":"iterator/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Iterator Design Pattern","title":"Video Lecture"},{"location":"iterator/#description","text":"An interface with next and has_next methods. next returns the next object in the aggregate(collection, list) has_next returns a value, usually a boolean indicating if the iterable is at the end of the list or not. The benefits of using the Iterator pattern is that the client, can traverse an aggregate without needing to understand it's internal representation and data structures.","title":"Description"},{"location":"iterator/#source-code","text":"","title":"Source Code"},{"location":"iterator/#iteratorpy","text":"from abc import ABCMeta , abstractmethod class IIterator ( metaclass = ABCMeta ): @staticmethod @abstractmethod def has_next (): \"\"\"Returns Boolean whether at end of collection or not\"\"\" @staticmethod @abstractmethod def next (): \"\"\"Return the object in collection\"\"\" class Iterable ( IIterator ): def __init__ ( self ): self . index = 0 self . maximum = 7 def next ( self ): if self . index < self . maximum : x = self . index self . index += 1 return x else : raise Exception ( \"AtEndOfIteratorException\" , \"At End of Iterator\" ) def has_next ( self ): return self . index < self . maximum ITERABLE = Iterable () while ITERABLE . has_next (): print ( ITERABLE . next ()) # print(ITERABLE.next()) # print(ITERABLE.next()) # print(ITERABLE.next()) # print(ITERABLE.next()) # print(ITERABLE.next()) # print(ITERABLE.next()) # print(ITERABLE.next()) # print(ITERABLE.next())","title":"iterator.py"},{"location":"mediator/","text":"Mediator Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Mediator Design Pattern Description The mediator pattern is a behavioural pattern that defines an object that encapsulates how a set of objects interact. With the mediator pattern, communication between objects is encapsulated within a mediator object. Objects communicate through the mediator rather than directly with each other. Source Code mediator.py from abc import ABCMeta , abstractmethod class IComponent ( metaclass = ABCMeta ): @staticmethod @abstractmethod def notify ( msg ): \"\"\"The required notify method\"\"\" @staticmethod @abstractmethod def receive ( msg ): \"\"\"The required receive method\"\"\" class Component ( IComponent ): def __init__ ( self , mediator , name ): self . mediator = mediator self . name = name def notify ( self , message ): print ( self . name + \": >>> Out >>> : \" + message ) self . mediator . notify ( message , self ) def receive ( self , message ): print ( self . name + \": <<< In <<< : \" + message ) class Mediator (): def __init__ ( self ): self . components = [] def add ( self , component ): self . components . append ( component ) def notify ( self , message , component ): for _component in self . components : if _component != component : _component . receive ( message ) MEDIATOR = Mediator () COMPONENT1 = Component ( MEDIATOR , \"Component1\" ) COMPONENT2 = Component ( MEDIATOR , \"Component2\" ) COMPONENT3 = Component ( MEDIATOR , \"Component3\" ) MEDIATOR . add ( COMPONENT1 ) MEDIATOR . add ( COMPONENT2 ) MEDIATOR . add ( COMPONENT3 ) COMPONENT1 . notify ( \"data\" )","title":"Mediator"},{"location":"mediator/#mediator-design-pattern","text":"","title":"Mediator Design Pattern"},{"location":"mediator/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Mediator Design Pattern","title":"Video Lecture"},{"location":"mediator/#description","text":"The mediator pattern is a behavioural pattern that defines an object that encapsulates how a set of objects interact. With the mediator pattern, communication between objects is encapsulated within a mediator object. Objects communicate through the mediator rather than directly with each other.","title":"Description"},{"location":"mediator/#source-code","text":"","title":"Source Code"},{"location":"mediator/#mediatorpy","text":"from abc import ABCMeta , abstractmethod class IComponent ( metaclass = ABCMeta ): @staticmethod @abstractmethod def notify ( msg ): \"\"\"The required notify method\"\"\" @staticmethod @abstractmethod def receive ( msg ): \"\"\"The required receive method\"\"\" class Component ( IComponent ): def __init__ ( self , mediator , name ): self . mediator = mediator self . name = name def notify ( self , message ): print ( self . name + \": >>> Out >>> : \" + message ) self . mediator . notify ( message , self ) def receive ( self , message ): print ( self . name + \": <<< In <<< : \" + message ) class Mediator (): def __init__ ( self ): self . components = [] def add ( self , component ): self . components . append ( component ) def notify ( self , message , component ): for _component in self . components : if _component != component : _component . receive ( message ) MEDIATOR = Mediator () COMPONENT1 = Component ( MEDIATOR , \"Component1\" ) COMPONENT2 = Component ( MEDIATOR , \"Component2\" ) COMPONENT3 = Component ( MEDIATOR , \"Component3\" ) MEDIATOR . add ( COMPONENT1 ) MEDIATOR . add ( COMPONENT2 ) MEDIATOR . add ( COMPONENT3 ) COMPONENT1 . notify ( \"data\" )","title":"mediator.py"},{"location":"observer/","text":"Observer Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Observer Design Pattern Description The observer pattern is a software design pattern in which an object, called the subject or observable, manages a list of dependents, called observers, and notifies them automatically of any internal state changes, and calls one of their methods. Source Code observer.py \"\"\" Observer Design Pattern \"\"\" from abc import ABCMeta , abstractmethod class IObservable ( metaclass = ABCMeta ): @staticmethod @abstractmethod def subscribe ( observer ): \"\"\"The subscribe method\"\"\" @staticmethod @abstractmethod def unsubscribe ( observer ): \"\"\"The unsubscribe method\"\"\" @staticmethod @abstractmethod def notify ( observer ): \"\"\"The notify method\"\"\" class Subject ( IObservable ): def __init__ ( self ): self . _observers = set () def subscribe ( self , observer ): self . _observers . add ( observer ) def unsubscribe ( self , observer ): self . _observers . remove ( observer ) def notify ( self , * args , ** kwargs ): for observer in self . _observers : observer . notify ( self , * args , ** kwargs ) class IObserver ( metaclass = ABCMeta ): @staticmethod @abstractmethod def notify ( observable , * args , ** kwargs ): \"\"\"Receive notifications\"\"\" class Observer ( IObserver ): def __init__ ( self , observable ): observable . subscribe ( self ) def notify ( self , observable , * args , ** kwargs ): print ( \"Observer received\" , args , kwargs ) SUBJECT = Subject () OBSERVERA = Observer ( SUBJECT ) OBSERVERB = Observer ( SUBJECT ) SUBJECT . notify ( \"Hello Observers\" ) SUBJECT . unsubscribe ( OBSERVERB ) SUBJECT . notify ( \"Hello Observers\" )","title":"Observer"},{"location":"observer/#observer-pattern","text":"","title":"Observer Pattern"},{"location":"observer/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Observer Design Pattern","title":"Video Lecture"},{"location":"observer/#description","text":"The observer pattern is a software design pattern in which an object, called the subject or observable, manages a list of dependents, called observers, and notifies them automatically of any internal state changes, and calls one of their methods.","title":"Description"},{"location":"observer/#source-code","text":"","title":"Source Code"},{"location":"observer/#observerpy","text":"\"\"\" Observer Design Pattern \"\"\" from abc import ABCMeta , abstractmethod class IObservable ( metaclass = ABCMeta ): @staticmethod @abstractmethod def subscribe ( observer ): \"\"\"The subscribe method\"\"\" @staticmethod @abstractmethod def unsubscribe ( observer ): \"\"\"The unsubscribe method\"\"\" @staticmethod @abstractmethod def notify ( observer ): \"\"\"The notify method\"\"\" class Subject ( IObservable ): def __init__ ( self ): self . _observers = set () def subscribe ( self , observer ): self . _observers . add ( observer ) def unsubscribe ( self , observer ): self . _observers . remove ( observer ) def notify ( self , * args , ** kwargs ): for observer in self . _observers : observer . notify ( self , * args , ** kwargs ) class IObserver ( metaclass = ABCMeta ): @staticmethod @abstractmethod def notify ( observable , * args , ** kwargs ): \"\"\"Receive notifications\"\"\" class Observer ( IObserver ): def __init__ ( self , observable ): observable . subscribe ( self ) def notify ( self , observable , * args , ** kwargs ): print ( \"Observer received\" , args , kwargs ) SUBJECT = Subject () OBSERVERA = Observer ( SUBJECT ) OBSERVERB = Observer ( SUBJECT ) SUBJECT . notify ( \"Hello Observers\" ) SUBJECT . unsubscribe ( OBSERVERB ) SUBJECT . notify ( \"Hello Observers\" )","title":"observer.py"},{"location":"prototype/","text":"Prototype Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Prototype Design Pattern Description Prototype design pattern is good for when creating a new objects may require more resources than you want to use or have available, versus just making a new copy in memory. Eg, A file you've downloaded from a server may be large, but since it is already in memory, you could just clone it, and work on the new copy independently of the original. In the prototype patterns interface, you create a static clone method that should be implemented by all classes that use the interface. How the clone method is implemented in the concrete class is up to you. You will need to decide whether a shallow or deep copy is required. A shallow copy, copies and creates new references 1 level deep, A deep copy, copies and creates new references for all levels. In Python you have mutable objects such as Lists, Dictionaries, Sets and any custom Objects you have created. A shallow copy, will create new copies of the objects with new references in memory, but the underlying data will point to the same location as the original copy. Be sure to test your implementation that the copy method you use works as you expect. Source Code prototype.py from abc import ABCMeta , abstractstaticmethod import copy class IProtoType ( metaclass = ABCMeta ): \"\"\"interface with clone method\"\"\" @abstractstaticmethod def clone (): \"\"\"The clone, deep or shallow, is up to how you want implement the details in your concrete class?\"\"\" class ConcreteClass1 ( IProtoType ): \"\"\"concrete class 1\"\"\" def __init__ ( self , i = 0 , s = \"\" , l = [], d = {}): self . i = i self . s = s self . l = l self . d = d def clone ( self ): return type ( self )( self . i , self . s , self . l . copy (), self . d . copy ()) def __str__ ( self ): return f \"{id(self)} \\t i={self.i} \\t s={self.s} \\t l={self.l} \\t d={self.d}\" class ConcreteClass2 ( IProtoType ): \"\"\"concrete class 2\"\"\" def __init__ ( self , i = 0 , s = \"\" , l = [], d = {}): self . i = i self . s = s self . l = l self . d = d def clone ( self ): return type ( self )( self . i , self . s , copy . deepcopy ( self . l ), copy . deepcopy ( self . d )) def __str__ ( self ): return f \"i={self.i} \\t\\t s={self.s} \\t l={self.l} \\t d={self.d} \\n {id(self.i)} \\t {id(self.s)} \\t {id(self.l)} \\t {id(self.d)} \\t \" if __name__ == \"__main__\" : OBJECT1 = ConcreteClass1 ( 1 , \"OBJECT1\" , [ 1 , 2 , 3 ], { \"a\" : 4 , \"b\" : 5 , \"c\" : 6 } ) print ( f \"OBJECT1 {OBJECT1}\" ) OBJECT2 = OBJECT1 . clone () OBJECT2 . s = \"OBJECT2\" OBJECT2 . l [ 0 ] = 10 print ( f \"OBJECT2 {OBJECT2}\" ) print ( f \"OBJECT1 {OBJECT1}\" )","title":"ProtoType"},{"location":"prototype/#prototype-design-pattern","text":"","title":"Prototype Design Pattern"},{"location":"prototype/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Prototype Design Pattern","title":"Video Lecture"},{"location":"prototype/#description","text":"Prototype design pattern is good for when creating a new objects may require more resources than you want to use or have available, versus just making a new copy in memory. Eg, A file you've downloaded from a server may be large, but since it is already in memory, you could just clone it, and work on the new copy independently of the original. In the prototype patterns interface, you create a static clone method that should be implemented by all classes that use the interface. How the clone method is implemented in the concrete class is up to you. You will need to decide whether a shallow or deep copy is required. A shallow copy, copies and creates new references 1 level deep, A deep copy, copies and creates new references for all levels. In Python you have mutable objects such as Lists, Dictionaries, Sets and any custom Objects you have created. A shallow copy, will create new copies of the objects with new references in memory, but the underlying data will point to the same location as the original copy. Be sure to test your implementation that the copy method you use works as you expect.","title":"Description"},{"location":"prototype/#source-code","text":"","title":"Source Code"},{"location":"prototype/#prototypepy","text":"from abc import ABCMeta , abstractstaticmethod import copy class IProtoType ( metaclass = ABCMeta ): \"\"\"interface with clone method\"\"\" @abstractstaticmethod def clone (): \"\"\"The clone, deep or shallow, is up to how you want implement the details in your concrete class?\"\"\" class ConcreteClass1 ( IProtoType ): \"\"\"concrete class 1\"\"\" def __init__ ( self , i = 0 , s = \"\" , l = [], d = {}): self . i = i self . s = s self . l = l self . d = d def clone ( self ): return type ( self )( self . i , self . s , self . l . copy (), self . d . copy ()) def __str__ ( self ): return f \"{id(self)} \\t i={self.i} \\t s={self.s} \\t l={self.l} \\t d={self.d}\" class ConcreteClass2 ( IProtoType ): \"\"\"concrete class 2\"\"\" def __init__ ( self , i = 0 , s = \"\" , l = [], d = {}): self . i = i self . s = s self . l = l self . d = d def clone ( self ): return type ( self )( self . i , self . s , copy . deepcopy ( self . l ), copy . deepcopy ( self . d )) def __str__ ( self ): return f \"i={self.i} \\t\\t s={self.s} \\t l={self.l} \\t d={self.d} \\n {id(self.i)} \\t {id(self.s)} \\t {id(self.l)} \\t {id(self.d)} \\t \" if __name__ == \"__main__\" : OBJECT1 = ConcreteClass1 ( 1 , \"OBJECT1\" , [ 1 , 2 , 3 ], { \"a\" : 4 , \"b\" : 5 , \"c\" : 6 } ) print ( f \"OBJECT1 {OBJECT1}\" ) OBJECT2 = OBJECT1 . clone () OBJECT2 . s = \"OBJECT2\" OBJECT2 . l [ 0 ] = 10 print ( f \"OBJECT2 {OBJECT2}\" ) print ( f \"OBJECT1 {OBJECT1}\" )","title":"prototype.py"},{"location":"proxy/","text":"Proxy Design Pattern Video Lecture Skillshare : https://skl.sh/34SM2Xg Udemy : Proxy Design Pattern Description The proxy design pattern is a class functioning as an interface to another class or object. A proxy could be for anything, such as a network connection, an object in memory, a file, or anything else you need to provide an abstraction between. It is a wrapper called by a client to access the real underlying object. Additional functionality can be provided at in the proxy abstraction if required. eg, caching, authorization, validation, lazy initialization, logging. The proxy should implement the subject interface as much as practicable so that the proxy and subject appear identical to the client. The Proxy Pattern may occasionally also be referred to as Monkey Patching or Object Augmentation Source Code proxy.py from abc import ABCMeta , abstractmethod import datetime class IComponent ( metaclass = ABCMeta ): @staticmethod @abstractmethod def method ( self ): \"\"\"A method to implement\"\"\" class Component ( IComponent ): def method ( self ): print ( \"The method has been called\" ) class ProxyComponent ( IComponent ): def __init__ ( self ): self . component = Component () def method ( self ): f = open ( \"log.txt\" , \"a\" ) f . write ( \" %s : method was proxied \\n \" % ( datetime . datetime . now ())) self . component . method () COMPONENT1 = Component () COMPONENT1 . method () COMPONENT2 = ProxyComponent () COMPONENT2 . method ()","title":"Proxy"},{"location":"proxy/#proxy-design-pattern","text":"","title":"Proxy Design Pattern"},{"location":"proxy/#video-lecture","text":"Skillshare : https://skl.sh/34SM2Xg Udemy : Proxy Design Pattern","title":"Video Lecture"},{"location":"proxy/#description","text":"The proxy design pattern is a class functioning as an interface to another class or object. A proxy could be for anything, such as a network connection, an object in memory, a file, or anything else you need to provide an abstraction between. It is a wrapper called by a client to access the real underlying object. Additional functionality can be provided at in the proxy abstraction if required. eg, caching, authorization, validation, lazy initialization, logging. The proxy should implement the subject interface as much as practicable so that the proxy and subject appear identical to the client. The Proxy Pattern may occasionally also be referred to as Monkey Patching or Object Augmentation","title":"Description"},{"location":"proxy/#source-code","text":"","title":"Source Code"},{"location":"proxy/#proxypy","text":"from abc import ABCMeta , abstractmethod import datetime class IComponent ( metaclass = ABCMeta ): @staticmethod @abstractmethod def method ( self ): \"\"\"A method to implement\"\"\" class Component ( IComponent ): def method ( self ): print ( \"The method has been called\" ) class ProxyComponent ( IComponent ): def __init__ ( self ): self . component = Component () def method ( self ): f = open ( \"log.txt\" , \"a\" ) f . write ( \" %s : method was proxied \\n \" % ( datetime . datetime . now ())) self . component . method () COMPONENT1 = Component () COMPONENT1 . method () COMPONENT2 = ProxyComponent () COMPONENT2 . method ()","title":"proxy.py"}]}