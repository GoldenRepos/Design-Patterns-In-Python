{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Design Patterns In Python The tutorials in this documentation supplement my Design Patterns in Python Courses on Skillshare and Udemy . To register for this course visit * Get 2 Months Free Premium Membership to 1000s of Courses * Full Lifetime Access * Subscription Model * Cancel Any Time Click Here to Register at Skillshare * One Time Payment (New Student Discount) * Full Lifetime Access * Certificate of Completion * 30 Day Money-Back Guarantee Click Here to Register at Udemy This course is about common GOF (Gang Of Four) Design Patterns implemented in Python. A Design Pattern is a description or template that can be repeatedly applied to a commonly recurring problem in software design. You will find a familiarity with Design Patterns very useful when planning, discussing, developing, managing and documenting your applications from now on and into the future. You will learn these Design Patterns Creational Factory Abstract Factory Builder Prototype Singleton Structural Decorator Adapter Facade Bridge Composite Flyweight Proxy Behavioural Command Chain of Responsibility Observer Pattern Interpreter Iterator Mediator Memento State Strategy Template Visitor Introduction Video","title":"Home"},{"location":"#design-patterns-in-python","text":"The tutorials in this documentation supplement my Design Patterns in Python Courses on Skillshare and Udemy . To register for this course visit * Get 2 Months Free Premium Membership to 1000s of Courses * Full Lifetime Access * Subscription Model * Cancel Any Time Click Here to Register at Skillshare * One Time Payment (New Student Discount) * Full Lifetime Access * Certificate of Completion * 30 Day Money-Back Guarantee Click Here to Register at Udemy This course is about common GOF (Gang Of Four) Design Patterns implemented in Python. A Design Pattern is a description or template that can be repeatedly applied to a commonly recurring problem in software design. You will find a familiarity with Design Patterns very useful when planning, discussing, developing, managing and documenting your applications from now on and into the future. You will learn these Design Patterns Creational Factory Abstract Factory Builder Prototype Singleton Structural Decorator Adapter Facade Bridge Composite Flyweight Proxy Behavioural Command Chain of Responsibility Observer Pattern Interpreter Iterator Mediator Memento State Strategy Template Visitor","title":"Design Patterns In Python"},{"location":"#introduction-video","text":"","title":"Introduction Video"},{"location":"abstract_factory/","text":"Abstract Factory Design Pattern The Abstract Factory Pattern adds an abstract layer over multiple factory method implementations. The Abstract Factory contains or composites one or more than one factory method Abstract Factory in the context of a Furniture factory Import existing factories from chair_factory import ChairFactory from table_factory import TableFactory Create an interface class IFurnitureFactory ( metaclass = ABCMeta ): \"\"\"Furniture Factory Interface\"\"\" @abstractstaticmethod def get_furniture ( furniture ): \"\"\"The static funiture factory interface method\"\"\" The factories abstract static method which delegates to the correct factory class FurnitureFactory ( IFurnitureFactory ): \"\"\"The Furniture Factory Concrete Class\"\"\" @staticmethod def get_furniture ( furniture ): \"\"\"Static get_furniture method\"\"\" try : if furniture in [ \"SmallChair\" , \"MediumChair\" , \"BigChair\" ]: return ChairFactory () . get_chair ( furniture ) if furniture in [ \"SmallTable\" , \"MediumTable\" , \"BigTable\" ]: return TableFactory () . get_table ( furniture ) raise AssertionError ( \"No Furniture Factory Found\" ) except AssertionError as _e : print ( _e ) return None Requesting from the abstract factory at run time if __name__ == \"__main__\" : FURNITURE = FurnitureFactory . get_furniture ( \"SmallChair\" ) print ( f \"{FURNITURE.__class__} : {FURNITURE.dimensions()}\" ) FURNITURE = FurnitureFactory . get_furniture ( \"MediumTable\" ) print ( f \"{FURNITURE.__class__} : {FURNITURE.dimensions()}\" )","title":"Abstract Factory"},{"location":"abstract_factory/#abstract-factory-design-pattern","text":"The Abstract Factory Pattern adds an abstract layer over multiple factory method implementations. The Abstract Factory contains or composites one or more than one factory method Abstract Factory in the context of a Furniture factory Import existing factories from chair_factory import ChairFactory from table_factory import TableFactory Create an interface class IFurnitureFactory ( metaclass = ABCMeta ): \"\"\"Furniture Factory Interface\"\"\" @abstractstaticmethod def get_furniture ( furniture ): \"\"\"The static funiture factory interface method\"\"\" The factories abstract static method which delegates to the correct factory class FurnitureFactory ( IFurnitureFactory ): \"\"\"The Furniture Factory Concrete Class\"\"\" @staticmethod def get_furniture ( furniture ): \"\"\"Static get_furniture method\"\"\" try : if furniture in [ \"SmallChair\" , \"MediumChair\" , \"BigChair\" ]: return ChairFactory () . get_chair ( furniture ) if furniture in [ \"SmallTable\" , \"MediumTable\" , \"BigTable\" ]: return TableFactory () . get_table ( furniture ) raise AssertionError ( \"No Furniture Factory Found\" ) except AssertionError as _e : print ( _e ) return None Requesting from the abstract factory at run time if __name__ == \"__main__\" : FURNITURE = FurnitureFactory . get_furniture ( \"SmallChair\" ) print ( f \"{FURNITURE.__class__} : {FURNITURE.dimensions()}\" ) FURNITURE = FurnitureFactory . get_furniture ( \"MediumTable\" ) print ( f \"{FURNITURE.__class__} : {FURNITURE.dimensions()}\" )","title":"Abstract Factory Design Pattern"},{"location":"adapter/","text":"Adapter Design Pattern The adapter design pattern solves these problems: How can a class be reused that does not have an interface that a client requires? How can classes that have incompatible interfaces work together? How can an alternative interface be provided for a class? In this lecture, I have 2 classes, they don't share the same interface. The client requires it's objects to use an already standardised interface. So we need to create an adapter, that wraps the incompatible object, but implements the standardised interface. Two Incompatible Classes After Creating an Adapter","title":"Adapter"},{"location":"adapter/#adapter-design-pattern","text":"The adapter design pattern solves these problems: How can a class be reused that does not have an interface that a client requires? How can classes that have incompatible interfaces work together? How can an alternative interface be provided for a class? In this lecture, I have 2 classes, they don't share the same interface. The client requires it's objects to use an already standardised interface. So we need to create an adapter, that wraps the incompatible object, but implements the standardised interface.","title":"Adapter Design Pattern"},{"location":"adapter/#two-incompatible-classes","text":"","title":"Two Incompatible Classes"},{"location":"adapter/#after-creating-an-adapter","text":"","title":"After Creating an Adapter"},{"location":"builder/","text":"Builder Design Pattern The Builder Pattern is a creational pattern whose intent is to separate the construction of a complex object from its representation so that you can use the same construction process to create different representations. The Builder Pattern tries to solve, - How can a class create different representations of a complex object? - How can a class that includes creating a complex object be simplified? The Builder and Factory patterns are very similar in the fact they both instantiate new objects at run time. The difference is when the process of creating the object is more complex, so rather than the Factory returning a new instance of ObjectA , it could call the builders director construct method ObjectA.construct() . Both return an Object. Parts of the Builder Pattern 1. Product - The Product being built 2. Concrete Builder - Build the concrete product. Implements the IBuilder interface 3. Builder Interface - The Interface which the Concrete builder should implement 4. Director - Has a construct method which when called creates a customised product The Builder Pattern in the context of a House Builder. There are multiple directors creating there own complex objects .","title":"Builder"},{"location":"builder/#builder-design-pattern","text":"The Builder Pattern is a creational pattern whose intent is to separate the construction of a complex object from its representation so that you can use the same construction process to create different representations. The Builder Pattern tries to solve, - How can a class create different representations of a complex object? - How can a class that includes creating a complex object be simplified? The Builder and Factory patterns are very similar in the fact they both instantiate new objects at run time. The difference is when the process of creating the object is more complex, so rather than the Factory returning a new instance of ObjectA , it could call the builders director construct method ObjectA.construct() . Both return an Object. Parts of the Builder Pattern 1. Product - The Product being built 2. Concrete Builder - Build the concrete product. Implements the IBuilder interface 3. Builder Interface - The Interface which the Concrete builder should implement 4. Director - Has a construct method which when called creates a customised product The Builder Pattern in the context of a House Builder. There are multiple directors creating there own complex objects .","title":"Builder Design Pattern"},{"location":"chain_of_responsibility/","text":"Chain of Responsibility Design Pattern Chain of responsibility pattern is a behavioural pattern used to achieve loose coupling in software design. In this example, a request from a client is passed to a chain of objects to process them. The objects in the chain will decide how to process them and/or pass them to the next in the chain. The objects can also modify the next in the chain if for example you wanted to run objects in a recursive manner. Chain of Responsibility Diagram Chain of Responsibility UML Diagram in the context of an ATM In the ATM example, the chain is created to dispense an amount of \u00a350, then \u00a320s and then \u00a310s in order. The successor chain is hard coded in the chain client. def __init__ ( self ): # initialize the successor chain self . chain1 = Dispenser50 () self . chain2 = Dispenser20 () self . chain3 = Dispenser10 () # set the chain of responsibility # The Client may compose chains once or # the handler can set them dynamically at # handle time self . chain1 . set_successor ( self . chain2 ) self . chain2 . set_successor ( self . chain3 ) You also have the option to set the next successor on logic at handle time. Output $ python atm.py Enter amount to withdrawal 130 Dispensing 2 \u00a350 note Dispensing 1 \u00a320 note Dispensing 1 \u00a310 note Go spoil yourself","title":"Chain of Responsibility"},{"location":"chain_of_responsibility/#chain-of-responsibility-design-pattern","text":"Chain of responsibility pattern is a behavioural pattern used to achieve loose coupling in software design. In this example, a request from a client is passed to a chain of objects to process them. The objects in the chain will decide how to process them and/or pass them to the next in the chain. The objects can also modify the next in the chain if for example you wanted to run objects in a recursive manner.","title":"Chain of Responsibility Design Pattern"},{"location":"chain_of_responsibility/#chain-of-responsibility-diagram","text":"","title":"Chain of Responsibility Diagram"},{"location":"chain_of_responsibility/#chain-of-responsibility-uml-diagram-in-the-context-of-an-atm","text":"In the ATM example, the chain is created to dispense an amount of \u00a350, then \u00a320s and then \u00a310s in order. The successor chain is hard coded in the chain client. def __init__ ( self ): # initialize the successor chain self . chain1 = Dispenser50 () self . chain2 = Dispenser20 () self . chain3 = Dispenser10 () # set the chain of responsibility # The Client may compose chains once or # the handler can set them dynamically at # handle time self . chain1 . set_successor ( self . chain2 ) self . chain2 . set_successor ( self . chain3 ) You also have the option to set the next successor on logic at handle time.","title":"Chain of Responsibility UML Diagram in the context of an ATM"},{"location":"chain_of_responsibility/#output","text":"$ python atm.py Enter amount to withdrawal 130 Dispensing 2 \u00a350 note Dispensing 1 \u00a320 note Dispensing 1 \u00a310 note Go spoil yourself","title":"Output"},{"location":"command/","text":"Command Design Pattern The command pattern is a behavioural design pattern, in which an abstraction exists between an object that invokes a command, and the object that performs it. The components if the Command Design Pattern are, 1. Receiver - The Object that will receive and execute the command 2. Invoker - Which will send the command to the receiver 3. Command Object - Itself, which implements an execute, or action method, and contains all required information to execute it 4. Client - The application or component which is aware of the Receiver, Invoker and Commands Eg, a button, will call the Invoker, which will call a pre registered Commands execute method, which the Receiver will perform. A Concrete Class will delegate a request to a command object, instead of implementing the request directly. Using a command design pattern allows you to separate concerns a little easier and to solve problems of the concerns independently of each of the layers. eg, logging the execution of a command and it's outcome. Uses: GUI Buttons, menus Macro recording Multi level undo/redo networking - send whole command objects across a network, even as a batch parallel processing or thread pools, transactional behaviour Wizards Notes: The receiver object should manages it's own state, not the command object There can be one or more invokers which can execute the command at a later date. The Command Pattern in the context of a light switch The Command Pattern in the context of a slider for a heater, which also implements UNDO/REDO","title":"Command"},{"location":"command/#command-design-pattern","text":"The command pattern is a behavioural design pattern, in which an abstraction exists between an object that invokes a command, and the object that performs it. The components if the Command Design Pattern are, 1. Receiver - The Object that will receive and execute the command 2. Invoker - Which will send the command to the receiver 3. Command Object - Itself, which implements an execute, or action method, and contains all required information to execute it 4. Client - The application or component which is aware of the Receiver, Invoker and Commands Eg, a button, will call the Invoker, which will call a pre registered Commands execute method, which the Receiver will perform. A Concrete Class will delegate a request to a command object, instead of implementing the request directly. Using a command design pattern allows you to separate concerns a little easier and to solve problems of the concerns independently of each of the layers. eg, logging the execution of a command and it's outcome. Uses: GUI Buttons, menus Macro recording Multi level undo/redo networking - send whole command objects across a network, even as a batch parallel processing or thread pools, transactional behaviour Wizards Notes: The receiver object should manages it's own state, not the command object There can be one or more invokers which can execute the command at a later date. The Command Pattern in the context of a light switch The Command Pattern in the context of a slider for a heater, which also implements UNDO/REDO","title":"Command Design Pattern"},{"location":"composite/","text":"Composite Design Pattern The Composite design pattern, - allows you to represent individual entities and groups of entities in the same manner. - is a structural design pattern that lets you compose objects into a tree. - is great if you need the option of swapping hierarchal relationships around. - makes it easier for you to add new kinds of components - provides flexibility of structure - conform to the Single Responsibility Principle in the way that it separates the aggregation of objects from the features of the object. Examples of using the Composite Design Pattern can be seen in a filesystem directory structure, where you can swap the hierarchy of folders, and in a drawing program where you can group, un-group and transform objects, and multiple objects at the same time.","title":"Composite"},{"location":"composite/#composite-design-pattern","text":"The Composite design pattern, - allows you to represent individual entities and groups of entities in the same manner. - is a structural design pattern that lets you compose objects into a tree. - is great if you need the option of swapping hierarchal relationships around. - makes it easier for you to add new kinds of components - provides flexibility of structure - conform to the Single Responsibility Principle in the way that it separates the aggregation of objects from the features of the object. Examples of using the Composite Design Pattern can be seen in a filesystem directory structure, where you can swap the hierarchy of folders, and in a drawing program where you can group, un-group and transform objects, and multiple objects at the same time.","title":"Composite Design Pattern"},{"location":"decorator/","text":"Decorator Design Pattern The decorator pattern is a structural pattern, that allows you to attach additional responsibilities to an object at run time. The decorator pattern is used in both the Object Oriented and Functional paradigms. The decorator pattern is different than the Python language feature of Python Decorators in it's syntax, but the application of it is the same, in the way that it is essentially a wrapper. The Decorator pattern adds extensibility, without modifying the original function.","title":"Decorator"},{"location":"decorator/#decorator-design-pattern","text":"The decorator pattern is a structural pattern, that allows you to attach additional responsibilities to an object at run time. The decorator pattern is used in both the Object Oriented and Functional paradigms. The decorator pattern is different than the Python language feature of Python Decorators in it's syntax, but the application of it is the same, in the way that it is essentially a wrapper. The Decorator pattern adds extensibility, without modifying the original function.","title":"Decorator Design Pattern"},{"location":"facade/","text":"Facade Design Pattern The Facade Pattern is a structural design pattern. It provides a simplified interface to a set of other interfaces, abstractions and implementations within a system that may be full of complexity and/or tightly coupled.","title":"Facade"},{"location":"facade/#facade-design-pattern","text":"The Facade Pattern is a structural design pattern. It provides a simplified interface to a set of other interfaces, abstractions and implementations within a system that may be full of complexity and/or tightly coupled.","title":"Facade Design Pattern"},{"location":"factory/","text":"Factory Design Pattern The Factory Pattern is a creational pattern that defines an Interface for creating an object and defers instantiation until runtime. Used when you don't know how many or what type of objects will be needed until or during runtime The Factory Pattern in the context of a Chair Factory class ObjectFactory : \"\"\"Tha Factory Class\"\"\" @staticmethod def get_concrete_object ( object_type ): \"\"\"A static method to get a concrete object of type class\"\"\" try : if object_type == \"ObjectA\" : return ObjectA () if object_type == \"ObjectB\" : return ObjectB () if object_type == \"ObjectC\" : return ObjectC () raise AssertionError ( \"Object Not Found\" ) except AssertionError as _e : print ( _e ) return None Each Object implements a Common Interface class ObjectA ( IObjectType ): \"\"\"The Object Concrete Class which implements the IObjectType interface\"\"\" ... Request from the factory at run time if __name__ == \"__main__\" : MY_OBJECT = ObjectFactory () . get_concrete_object ( \"ObjectB\" ) print ( MY_OBJECT . dimensions ())","title":"Factory"},{"location":"factory/#factory-design-pattern","text":"The Factory Pattern is a creational pattern that defines an Interface for creating an object and defers instantiation until runtime. Used when you don't know how many or what type of objects will be needed until or during runtime The Factory Pattern in the context of a Chair Factory class ObjectFactory : \"\"\"Tha Factory Class\"\"\" @staticmethod def get_concrete_object ( object_type ): \"\"\"A static method to get a concrete object of type class\"\"\" try : if object_type == \"ObjectA\" : return ObjectA () if object_type == \"ObjectB\" : return ObjectB () if object_type == \"ObjectC\" : return ObjectC () raise AssertionError ( \"Object Not Found\" ) except AssertionError as _e : print ( _e ) return None Each Object implements a Common Interface class ObjectA ( IObjectType ): \"\"\"The Object Concrete Class which implements the IObjectType interface\"\"\" ... Request from the factory at run time if __name__ == \"__main__\" : MY_OBJECT = ObjectFactory () . get_concrete_object ( \"ObjectB\" ) print ( MY_OBJECT . dimensions ())","title":"Factory Design Pattern"},{"location":"iterator/","text":"Iterator Design Pattern An interface with next and has_next methods. next returns the next object in the aggregate(collection, list) has_next returns a value, usually a boolean indicating if the iterable is at the end of the list or not. The benefits of using the Iterator pattern is that the client, can traverse an aggregate without needing to understand it's internal representation and data structures.","title":"Iterator"},{"location":"iterator/#iterator-design-pattern","text":"An interface with next and has_next methods. next returns the next object in the aggregate(collection, list) has_next returns a value, usually a boolean indicating if the iterable is at the end of the list or not. The benefits of using the Iterator pattern is that the client, can traverse an aggregate without needing to understand it's internal representation and data structures.","title":"Iterator Design Pattern"},{"location":"mediator/","text":"Mediator Design Pattern The mediator pattern is a behavioural pattern that defines an object that encapsulates how a set of objects interact. With the mediator pattern, communication between objects is encapsulated within a mediator object. Objects communicate through the mediator rather than directly with each other.","title":"Mediator"},{"location":"mediator/#mediator-design-pattern","text":"The mediator pattern is a behavioural pattern that defines an object that encapsulates how a set of objects interact. With the mediator pattern, communication between objects is encapsulated within a mediator object. Objects communicate through the mediator rather than directly with each other.","title":"Mediator Design Pattern"},{"location":"observer/","text":"Observer Pattern The observer pattern is a software design pattern in which an object, called the subject or observable, manages a list of dependents, called observers, and notifies them automatically of any internal state changes, and calls one of their methods.","title":"Observer"},{"location":"observer/#observer-pattern","text":"The observer pattern is a software design pattern in which an object, called the subject or observable, manages a list of dependents, called observers, and notifies them automatically of any internal state changes, and calls one of their methods.","title":"Observer Pattern"},{"location":"prototype/","text":"Prototype Design Pattern Prototype design pattern is good for when creating a new objects may require more resources than you want to use or have available, versus just making a new copy in memory. Eg, A file you've downloaded from a server may be large, but since it is already in memory, you could just clone it, and work on the new copy independently of the original. In the prototype patterns interface, you create a static clone method that should be implemented by all classes that use the interface. How the clone method is implemented in the concrete class is up to you. You will need to decide whether a shallow or deep copy is required. A shallow copy, copies and creates new references 1 level deep, A deep copy, copies and creates new references for all levels. In Python you have mutable objects such as Lists, Dictionaries, Sets and any custom Objects you have created. A shallow copy, will create new copies of the objects with new references in memory, but the underlying data will point to the same location as the original copy. Be sure to test your implementation that the copy method you use works as you expect.","title":"ProtoType"},{"location":"prototype/#prototype-design-pattern","text":"Prototype design pattern is good for when creating a new objects may require more resources than you want to use or have available, versus just making a new copy in memory. Eg, A file you've downloaded from a server may be large, but since it is already in memory, you could just clone it, and work on the new copy independently of the original. In the prototype patterns interface, you create a static clone method that should be implemented by all classes that use the interface. How the clone method is implemented in the concrete class is up to you. You will need to decide whether a shallow or deep copy is required. A shallow copy, copies and creates new references 1 level deep, A deep copy, copies and creates new references for all levels. In Python you have mutable objects such as Lists, Dictionaries, Sets and any custom Objects you have created. A shallow copy, will create new copies of the objects with new references in memory, but the underlying data will point to the same location as the original copy. Be sure to test your implementation that the copy method you use works as you expect.","title":"Prototype Design Pattern"},{"location":"proxy/","text":"Proxy Design Pattern The proxy design pattern is a class functioning as an interface to another class or object. A proxy could be for anything, such as a network connection, an object in memory, a file, or anything else you need to provide an abstraction between. It is a wrapper called by a client to access the real underlying object. Additional functionality can be provided at in the proxy abstraction if required. eg, caching, authorization, validation, lazy initialization, logging. The proxy should implement the subject interface as much as practicable so that the proxy and subject appear identical to the client. The Proxy Pattern may occasionally also be referred to as Monkey Patching or Object Augmentation","title":"Proxy"},{"location":"proxy/#proxy-design-pattern","text":"The proxy design pattern is a class functioning as an interface to another class or object. A proxy could be for anything, such as a network connection, an object in memory, a file, or anything else you need to provide an abstraction between. It is a wrapper called by a client to access the real underlying object. Additional functionality can be provided at in the proxy abstraction if required. eg, caching, authorization, validation, lazy initialization, logging. The proxy should implement the subject interface as much as practicable so that the proxy and subject appear identical to the client. The Proxy Pattern may occasionally also be referred to as Monkey Patching or Object Augmentation","title":"Proxy Design Pattern"}]}